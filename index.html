<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”ï¸ é€²éš GPX ç™»å±±ç®¡ç†å·¥å…· (å°ˆæ¥­åŠŸèƒ½ç‰ˆ)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js"></script>
    <style>
        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --bg-dark: #1a1a2e;
            --panel-bg: rgba(255, 255, 255, 0.98);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: var(--bg-dark);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* é ‚éƒ¨æ§åˆ¶é¢æ¿ */
        #header {
            background: white;
            padding: 12px 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 1500;
            transition: all 0.3s ease;
            max-height: 400px;
            overflow: hidden;
        }

        #header.collapsed {
            max-height: 0;
            padding: 0 20px;
            border: none;
        }

        #header-handle {
            height: 12px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            z-index: 1600;
        }

        h1 {
            color: #333;
            margin: 0 0 8px 0;
            font-size: 18px;
        }

        #toolbar {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .action-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            color: white;
        }

        .export-btn {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
        }

        .add-waypoint-btn {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .photo-btn {
            background: #444;
        }

        .snapshot-btn {
            background: linear-gradient(135deg, #FF512F 0%, #DD2476 100%);
        }

        .zoom-btn {
            background: #fff;
            color: #333;
            border: 1px solid #ccc;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            margin-left: 4px;
            cursor: pointer;
        }

        #route-list {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 5px;
        }

        .route-wrapper {
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.05);
            padding: 2px 8px;
            border-radius: 15px;
            border: 1px solid #ddd;
        }

        .route-button {
            padding: 2px 8px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 11px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* åœ°åœ–å€åŸŸ */
        #main-content {
            flex: 1;
            overflow: hidden;
            position: relative;
            display: flex;
        }

        #map {
            flex: 1;
            z-index: 1;
        }

        /* å³å´è³‡è¨Šé¢æ¿ */
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 260px;
            background: var(--panel-bg);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            padding: 15px;
            display: none;
            flex-direction: column;
            gap: 8px;
            border: 1px solid #eee;
        }

        #info-panel.active {
            display: flex;
        }

        #info-panel h3 {
            color: var(--secondary);
            font-size: 15px;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 5px;
            margin-bottom: 5px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #555;
            padding: 2px 0;
        }

        .info-row b {
            color: #000;
        }

        /* åº•éƒ¨é«˜åº¦åœ– */
        #elevation-panel {
            position: absolute;
            bottom: 0;
            left: 25%;
            width: 50%;
            background: white;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);
            transition: transform 0.4s ease;
            height: 180px;
            display: none;
            flex-direction: column;
            z-index: 2000;
            border-radius: 12px 12px 0 0;
            border: 1px solid #eee;
        }

        #elevation-panel.active {
            display: flex;
        }

        #elevation-panel.collapsed {
            transform: translateY(148px);
        }

        #elevation-toggle-handle {
            height: 32px;
            background: #f8f9fa;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            /* Changed from center to space-between */
            padding: 0 10px;
            /* Add padding */
            font-size: 11px;
            font-weight: bold;
            color: #666;
            border-bottom: 1px solid #eee;
        }

        .chart-controls-container {
            display: flex;
            gap: 4px;
        }

        #elevation-content {
            flex: 1;
            padding: 5px 15px;
            position: relative;
        }

        /* æ¨™ç±¤æ¨£å¼ */
        .wp-label {
            background: rgba(255, 255, 255, 0.95);
            border: 1.5px solid var(--secondary);
            border-radius: 4px;
            padding: 2px 6px;
            font-weight: bold;
            font-size: 11px;
            color: #333;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            pointer-events: none;
            white-space: nowrap;
        }

        .photo-label {
            border-color: var(--primary);
            color: var(--primary);
        }

        /* é‡Œç¨‹æ¨™è¨˜æ¨£å¼ */
        .km-marker {
            background: white;
            border: 2px solid #333;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 3000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 12px;
            width: 350px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .photo-marker-icon {
            background: white;
            border: 2.5px solid var(--primary);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            font-size: 18px;
            line-height: 1;
        }

        .slope-legend {
            position: absolute;
            bottom: 40px;
            left: 20px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: none;
        }

        #selection-stats {
            position: absolute;
            bottom: 190px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            display: none;
            z-index: 2001;
            /* pointer-events: none; REMOVED to allow button clicking */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .slope-legend.active {
            display: block;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 11px;
        }

        .color-bar {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }

        @media (max-width: 1024px) {
            #elevation-panel {
                width: 80%;
                left: 10%;
            }
        }

        @media (max-width: 768px) {
            #elevation-panel {
                width: 94%;
                left: 3%;
            }

            #info-panel {
                width: 220px;
                top: 10px;
                right: 10px;
            }
        }

        /* æœå°‹èˆ‡å¤©æ°£æ¨£å¼ */
        #search-results {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            width: 220px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            display: none;
            z-index: 2000;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
        }

        .search-item {
            padding: 8px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 12px;
        }

        .search-item:hover {
            background: #f0f0f0;
        }

        .weather-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .weather-card {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #eee;
        }

        .weather-date {
            font-size: 10px;
            color: #666;
            margin-bottom: 4px;
        }

        .weather-icon {
            font-size: 20px;
            margin: 4px 0;
        }

        .weather-temp {
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }

        .weather-desc {
            font-size: 10px;
            color: #555;
        }

        .chart-btn {
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 3px 8px;
            cursor: pointer;
            font-size: 11px;
            color: #444;
        }

        .chart-btn:hover {
            background: #f0f0f0;
        }

        .chart-btn.active {
            background: #2196f3;
            color: white;
            border-color: #1976d2;
        }

        /* Floating Actions - Always visible at bottom right */
        #floating-actions {
            position: absolute;
            bottom: 30px;
            right: 20px;
            z-index: 3000;
            display: flex;
            flex-direction: column-reverse;
            gap: 12px;
        }

        .fab-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .fab-btn:hover {
            transform: scale(1.1);
            background: #f8f9fa;
        }

        /* Full Screen Mode */
        body.fullscreen-mode #header,
        body.fullscreen-mode #elevation-panel,
        body.fullscreen-mode #header-handle {
            display: none !important;
        }

        body.fullscreen-mode #info-panel {
            top: 20px;
            left: 20px;
        }

        /* Snapshot Mode: Hide UI clutter */
        body.snapshot-active #floating-actions,
        body.snapshot-active .modal {
            display: none !important;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="header">
            <h1>ğŸ”ï¸ GPX ç™»å±±ç®¡ç†å“¡ (å°ˆæ¥­é€£å‹•ç‰ˆ)</h1>
            <div id="toolbar">
                <input type="file" id="fileInput" multiple accept=".gpx" style="font-size: 11px; width: 180px;" />
                <button class="action-btn add-waypoint-btn" id="addWaypointBtn" disabled>ğŸ“ æ–°å¢åœ°æ¨™</button>
                <button class="action-btn export-btn" id="exportBtn" disabled>ğŸ’¾ åŒ¯å‡º GPX</button>
                <button class="action-btn photo-btn" onclick="document.getElementById('photo-input').click()">ğŸ“·
                    ä¸Šå‚³ç…§ç‰‡</button>
                <input type="file" id="photo-input" multiple accept="image/jpeg,image/jpg" style="display:none;" />
                <button class="action-btn time-btn" id="estimateTimeBtn" style="background:#8e44ad;">â±ï¸ æ™‚é–“é ä¼°</button>
                <div style="width:1px; height:20px; background:#ddd; margin:0 4px;"></div>
                <button class="action-btn" id="navBtn" style="background:#2980b9;">ğŸ›°ï¸ é–‹å§‹å°èˆª</button>
                <button class="action-btn" id="offlineBtn" style="background:#7f8c8d;">ğŸ’¾ é›¢ç·šåœ°åœ–</button>
                <button class="action-btn" id="locateBtn"
                    style="background:#fff; color:#2980b9; border:1px solid #2980b9; display:none;">â— å®šä½æˆ‘</button>
                <span id="gps-status" style="font-size:10px; color:#666; display:none;"></span>

                <label style="font-size: 12px; cursor: pointer; margin-left: 8px;">
                    <input type="checkbox" id="slopeToggle"> ğŸ¨ é¡¯ç¤ºå¡åº¦
                </label>
                <label
                    style="font-size: 12px; cursor: pointer; margin-left: 8px; border-left: 1px solid #ddd; padding-left: 8px;">
                    <input type="checkbox" id="labelToggle" checked> ğŸ·ï¸ é¡¯ç¤ºæ¨™è¨˜
                </label>
                <div style="position:relative; margin-left:8px;">
                    <input type="text" id="searchInput" placeholder="ğŸ” æœå°‹åœ°é»..."
                        style="font-size: 11px; padding: 5px; width: 140px; border:1px solid #ccc; border-radius:4px;">
                    <button id="searchBtn" style="padding: 5px; cursor: pointer;">Go</button>
                    <div id="search-results"></div>
                </div>
            </div>
            <div id="route-list"></div>
        </div>
        <div id="header-handle">â–²</div>

        <!-- Floating Action Buttons -->
        <div id="floating-actions">
            <button class="fab-btn" onclick="toggleFullScreen()" title="å…¨è¢å¹•">â›¶</button>
            <button class="fab-btn" onclick="takeSnapshot()" title="ç•«é¢å¿«ç…§">ğŸ“¸</button>
        </div>

        <div id="main-content">
            <div id="map"></div>

            <div id="info-panel">
                <h3 id="info-name">è·¯ç·šçµ±è¨ˆæ•¸æ“š</h3>
                <div class="info-row"><span>è·¯å¾‘åç¨±</span><b id="info-disp-name">-</b></div>
                <div class="info-row"><span>ç¸½é‡Œç¨‹</span><b id="info-dist">- km</b></div>
                <div class="info-row"><span>æœ€é«˜æµ·æ‹”</span><b id="info-max-ele">- m</b></div>
                <div class="info-row"><span>æœ€ä½æµ·æ‹”</span><b id="info-min-ele">- m</b></div>
                <div class="info-row"><span>ç´¯ç©çˆ¬å‡</span><b id="info-gain">- m</b></div>
                <div class="info-row"><span>å¹³å‡é€Ÿåº¦</span><b id="info-speed">- km/h</b></div>
                <div class="info-row"><span>ç¸½è€—æ™‚</span><b id="info-duration">-</b></div>
                <div class="info-row"><span>é–‹å§‹</span><b id="info-start" style="font-size: 10px;">-</b></div>
                <div class="info-row"><span>çµæŸ</span><b id="info-end" style="font-size: 10px;">-</b></div>
            </div>

            <div class="slope-legend" id="slopeLegend">
                <div class="legend-item">
                    <div class="color-bar" style="background:#22c55e;"></div><span>å¹³ç·©</span>
                </div>
                <div class="legend-item">
                    <div class="color-bar" style="background:#eab308;"></div><span>ç·©å¡</span>
                </div>
                <div class="legend-item">
                    <div class="color-bar" style="background:#f97316;"></div><span>é™¡å¡</span>
                </div>
                <div class="legend-item">
                    <div class="color-bar" style="background:#ef4444;"></div><span>æ¥µé™¡</span>
                </div>
                <div class="legend-item">
                    <div class="color-bar" style="background:#3b82f6;"></div><span>ä¸‹å¡</span>
                </div>
            </div>
        </div>

        <!-- Remove absolute chart-controls -->

        <div id="elevation-panel">
            <div id="elevation-toggle-handle">
                <span id="toggle-text">â–¼ æ”¶åˆé«˜åº¦åœ–</span>
                <div class="chart-controls-container" onclick="event.stopPropagation()">
                    <button class="chart-btn active" data-type="ele" onclick="switchChart('ele')">â›°ï¸ é«˜åº¦</button>
                    <button class="chart-btn" data-type="slope" onclick="switchChart('slope')">ğŸ“ å¡åº¦</button>
                    <button class="chart-btn" data-type="speed" onclick="switchChart('speed')">ğŸš€ é€Ÿåº¦</button>
                </div>
            </div>
            <div id="elevation-content">
                <canvas id="elevation-chart"></canvas>
            </div>
        </div>
    </div>
    </div>

    <div id="selection-stats">
        å€é–“: <span id="sel-dist">0</span> km | çˆ¬å‡: <span id="sel-gain">0</span> m | å¡åº¦: <span id="sel-slope">0</span>%
    </div>
    </div>
    </div>

    <!-- æ¨¡æ…‹è¦–çª— -->
    <div id="exportModal" class="modal">
        <div class="modal-content">
            <h3>ğŸ’¾ é¸æ“‡åŒ¯å‡ºå…§å®¹</h3>
            <div id="export-choices"
                style="margin: 12px 0; max-height: 150px; overflow-y: auto; border: 1px solid #eee; padding: 8px;">
            </div>
            <label style="font-size:12px; cursor:pointer;"><input type="checkbox" id="chk-export-wp" checked>
                åŒ…å«æ‰€æœ‰æ¨™è¨˜é»</label>
            <div style="display:flex; gap:10px; margin-top:15px;">
                <button class="action-btn export-btn" style="flex:1" id="finalExportBtn">ä¸‹è¼‰ GPX</button>
                <button class="action-btn" style="flex:1; background:#ccc; color:#333;"
                    onclick="closeModal('exportModal')">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <div id="namingModal" class="modal">
        <div class="modal-content">
            <h3 id="namingTitle">ğŸ“ è¨­å®šæ¨™è¨˜åç¨±</h3>
            <input type="text" id="targetNameInput"
                style="width:100%; padding:10px; margin:15px 0; border:1px solid #ddd; border-radius:4px;" />
            <div style="display:flex; gap:10px;">
                <button class="action-btn add-waypoint-btn" style="flex:1" id="confirmNaming">ç¢ºå®š</button>
                <button class="action-btn" style="flex:1; background:#ccc; color:#333;"
                    onclick="closeModal('namingModal')">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <div id="timeModal" class="modal">
        <div class="modal-content">
            <h3>â±ï¸ ç™»å±±æ™‚é–“é ä¼°</h3>
            <div style="margin:15px 0; font-size:13px; color:#555;">
                <p>åŸºæ–¼ç¸½é‡Œç¨‹ <span id="tm-dist" style="font-weight:bold; color:#333;">0</span> km èˆ‡ç¸½çˆ¬å‡ <span id="tm-gain"
                        style="font-weight:bold; color:#d32f2f;">0</span> m è¨ˆç®—ã€‚</p>
            </div>

            <div
                style="background:#f8f9fa; padding:10px; border-radius:6px; margin-bottom:10px; border-left:4px solid #667eea;">
                <div style="font-size:11px; color:#666; margin-bottom:4px;">ä¸€èˆ¬è…³ç¨‹ (Naismith's Rule)</div>
                <div style="font-size:18px; font-weight:bold; color:#333;" id="tm-normal">-</div>
                <div style="font-size:10px; color:#888;">å¹³è·¯ 4km/h + æ¯çˆ¬å‡ 600m åŠ  1 å°æ™‚</div>
            </div>

            <div
                style="background:#fff3e0; padding:10px; border-radius:6px; margin-bottom:15px; border-left:4px solid #f57c00;">
                <div style="font-size:11px; color:#666; margin-bottom:4px;">ä¿å®ˆ/é‡è£ (Munter Method)</div>
                <div style="font-size:18px; font-weight:bold; color:#e65100;" id="tm-conservative">-</div>
                <div style="font-size:10px; color:#888;">(è·é›¢ + çˆ¬å‡/100) / 4</div>
            </div>

            <div style="margin-bottom:15px;">
                <label style="font-size:12px; display:block; margin-bottom:5px;">é€Ÿåº¦èª¿æ•´ä¿‚æ•¸: <span
                        id="pace-val">1.0</span>x</label>
                <input type="range" id="pace-slider" min="0.5" max="1.5" step="0.1" value="1.0" style="width:100%;">
                <div style="display:flex; justify-content:space-between; font-size:10px; color:#888;">
                    <span>æ…¢ (0.5x)</span>
                    <span>å¿« (1.5x)</span>
                </div>
            </div>

            <div style="display:flex; gap:10px;">
                <button class="action-btn" style="flex:1; background:#ccc; color:#333;"
                    onclick="closeModal('timeModal')">é—œé–‰</button>
            </div>
        </div>
    </div>

    <div id="weatherModal" class="modal">
        <div class="modal-content" style="width: 500px; max-width: 95%;">
            <h3 id="weatherTitle">ğŸŒ¤ï¸ å¤©æ°£é å ±</h3>
            <div id="weatherContent"
                style="min-height: 100px; display: flex; align-items: center; justify-content: center;">è¼‰å…¥ä¸­...</div>
            <div style="display:flex; margin-top:15px; justify-content: flex-end;">
                <button class="action-btn" style="background:#ccc; color:#333;"
                    onclick="closeModal('weatherModal')">é—œé–‰</button>
            </div>
        </div>
    </div>

    <div id="offlineModal" class="modal">
        <div class="modal-content" style="width: 400px;">
            <h3>ğŸ’¾ é›¢ç·šåœ°åœ–é è¼‰ (Cache)</h3>
            <div style="font-size:12px; color:#666; margin:10px 0; line-height:1.5;">
                <p>æ­¤åŠŸèƒ½æœƒå°‡<b>ç›®å‰ç•«é¢ç¯„åœ</b>å…§çš„åœ°åœ–åœ–ç‰‡ã€Œçœ‹éä¸€éã€ï¼Œä½¿å…¶å„²å­˜æ–¼ç€è¦½å™¨å¿«å–ä¸­ã€‚</p>
                <p style="color:#d35400;">âš ï¸ æ³¨æ„ï¼šè«‹åœ¨æœ‰ Wi-Fi çš„ç’°å¢ƒä¸‹æ“ä½œã€‚è‹¥æ¸…é™¤ç€è¦½å™¨å¿«å–ï¼Œåœ°åœ–å°‡æœƒæ¶ˆå¤±ã€‚</p>
            </div>

            <div
                style="background:#f8f9fa; padding:10px; border-radius:6px; margin-bottom:15px; border:1px solid #eee;">
                <div class="info-row"><span>ç›®å‰åœ–å±¤</span><b id="off-layer-name">-</b></div>
                <div class="info-row"><span>ç•¶å‰ç¸®æ”¾ (Zoom)</span><b id="off-current-zoom">-</b></div>
                <div class="info-row"><span>é è¼‰ç¯„åœ (Zoom)</span>
                    <select id="off-zoom-select" style="font-size:11px; padding:2px;">
                        <option value="0">åƒ…ç›®å‰å±¤ç´š</option>
                        <option value="1">ç›®å‰ + ä¸‹ä¸€å±¤ (+1)</option>
                        <option value="2" selected>ç›®å‰ ~ ç´°ç¯€ (+2)</option>
                    </select>
                </div>
                <div class="info-row" style="margin-top:5px; border-top:1px solid #ddd; padding-top:5px;">
                    <span>é ä¼°åœ–ç£šæ•¸é‡</span><b id="off-tile-count" style="color:#2980b9;">0</b>
                </div>
            </div>

            <div id="off-progress-container" style="display:none; margin-bottom:15px;">
                <div style="display:flex; justify-content:space-between; font-size:11px; margin-bottom:2px;">
                    <span id="off-status-text">ä¸‹è¼‰ä¸­...</span>
                    <span id="off-percent">0%</span>
                </div>
                <div style="width:100%; height:8px; background:#eee; border-radius:4px; overflow:hidden;">
                    <div id="off-progress-bar"
                        style="width:0%; height:100%; background:#27ae60; transition:width 0.2s;"></div>
                </div>
            </div>

            <div style="display:flex; gap:10px;">
                <button class="action-btn" id="startDownloadBtn" style="flex:1; background:#27ae60;">ğŸš€ é–‹å§‹å¿«å–</button>
                <button class="action-btn" style="flex:1; background:#ccc; color:#333;"
                    onclick="closeModal('offlineModal')">é—œé–‰</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const APP_VERSION = '1.3.0';
            document.querySelector('#header h1').innerHTML += ` <span style="font-size:12px; color:#666; font-weight:normal;">v${APP_VERSION}</span>`;

            const routes = [], waypoints = [], photos = [];
            let trackPointsPool = [], isAddingWaypoint = false, currentNamingTarget = null, pendingWaypointLatLng = null, elevationChart = null, syncMarker = null;
            let selectionPolyline = null; // ç”¨æ–¼é€²éšåˆ†æ
            let dragStartIndex = -1; // ç”¨æ–¼åœ–è¡¨æ‹–æ›³

            // Chart State
            let currentChartType = 'ele'; // ele, slope, speed
            let currentRoute = null;

            window.switchChart = (type) => {
                currentChartType = type;
                document.querySelectorAll('.chart-btn').forEach(b => {
                    b.classList.toggle('active', b.dataset.type === type);
                });
                if (currentRoute) showElevation(currentRoute);
            };

            function calculateSmoothedSlope(pts) {
                const windowSize = 3;
                return pts.map((p, i) => {
                    const start = Math.max(0, i - windowSize);
                    const end = Math.min(pts.length - 1, i + windowSize);
                    if (start >= end) return 0;
                    const dDist = pts[end].dist - pts[start].dist;
                    return dDist > 10 ? ((pts[end].ele - pts[start].ele) / dDist) * 100 : 0;
                });
            }

            function calculateSmoothedSpeed(pts) {
                const windowSize = 5;
                return pts.map((p, i) => {
                    const start = Math.max(0, i - windowSize);
                    const end = Math.min(pts.length - 1, i + windowSize);
                    if (start >= end) return 0;
                    const dDist = (pts[end].dist - pts[start].dist) / 1000; // km
                    const dTime = (pts[end].time.getTime() - pts[start].time.getTime()) / 3600000; // hr
                    return dTime > 0.001 ? (dDist / dTime) : 0;
                });
            }

            const pathColors = ['#ff00ff', '#00ffff', '#ff3300', '#ffff00', '#9900ff', '#00ff00', '#ff9900', '#0066ff'];

            // æ¨£å¼åœ–å±¤å®šç¾©
            // æ¨£å¼åœ–å±¤å®šç¾©
            // æ¨£å¼åœ–å±¤å®šç¾©
            // Fix for html2canvas alignment issues: Disable 3D transforms - REMOVED to fix zoom
            // L.Browser.any3d = false;

            const streetMap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM', maxZoom: 19, crossOrigin: true });
            const terrainMap = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenTopoMap', crossOrigin: true });
            const satelliteMap = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: '&copy; Esri', crossOrigin: true });
            const esriTopo = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', { attribution: '&copy; Esri', maxZoom: 19, crossOrigin: true });

            // ç™»å±±è·¯å¾‘ç–ŠåŠ å±¤
            const hikingTrails = L.tileLayer('https://tile.waymarkedtrails.org/hiking/{z}/{x}/{y}.png', { attribution: '&copy; Waymarked Trails', maxZoom: 18, opacity: 0.8, crossOrigin: true });

            const map = L.map('map', {
                zoomControl: false,
                zoomSnap: 0.25, // Allow fractional zoom for better fit
                zoomDelta: 0.25, // Smaller zoom steps
                layers: [streetMap, hikingTrails] // é è¨­ä½¿ç”¨ OSM + ç™»å±±è·¯å¾‘
            }).setView([23.5, 121], 7);

            // Add zoom control manually to respect zoomDelta or custom position if needed
            L.control.zoom({ position: 'topright' }).addTo(map);

            // åœ–å±¤æ§åˆ¶å™¨
            const baseMaps = {
                "OpenStreetMap (æ¨™æº–)": streetMap,
                "Esri ä¸–ç•Œåœ°å½¢åœ–": esriTopo,
                "ç­‰é«˜åœ°å½¢ (OpenTopo)": terrainMap,
                "è¡›æ˜Ÿå½±åƒ": satelliteMap
            };

            const overlayMaps = {
                "ğŸ¥¾ ç™»å±±è·¯å¾‘ (Waymarked)": hikingTrails
            };

            L.control.layers(baseMaps, overlayMaps, { position: 'topright' }).addTo(map);

            syncMarker = L.circleMarker([0, 0], { radius: 7, color: '#fff', fillColor: '#ff0000', fillOpacity: 1, weight: 2, opacity: 0, zIndexOffset: 2000 }).addTo(map);

            // 1. ç…§ç‰‡è§£æé‚è¼¯
            document.getElementById('photo-input').addEventListener('change', function (e) {
                const files = Array.from(e.target.files);
                if (trackPointsPool.length === 0) return alert("è«‹å…ˆè¼‰å…¥ GPX è»Œè·¡ï¼");

                files.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = function (ev) {
                        try {
                            const exifData = EXIF.readFromBinaryFile(ev.target.result) || {};
                            const dateTimeStr = exifData.DateTimeOriginal || exifData.CreateDate || exifData.ModifyDate;
                            if (!dateTimeStr) return alert(`ç…§ç‰‡ [${file.name}] æ‰¾ä¸åˆ°æ™‚é–“è³‡è¨Šã€‚`);
                            const photoDate = parseExifDate(dateTimeStr);
                            matchPhotoToTrack(file, photoDate);
                        } catch (err) { alert(`è®€å–ç…§ç‰‡ EXIF å¤±æ•—ã€‚`); }
                    };
                    reader.readAsArrayBuffer(file);
                });
                e.target.value = '';
            });

            function parseExifDate(s) {
                const b = s.split(/[: ]/);
                return new Date(b[0], b[1] - 1, b[2], b[3], b[4], b[5]);
            }

            function matchPhotoToTrack(file, photoDate) {
                const MAX_DIFF = 3 * 3600 * 1000;
                const offsets = [0, -8, +8];
                let bestMatch = null;
                for (const h of offsets) {
                    const shifted = new Date(photoDate.getTime() + h * 3600 * 1000);
                    const candidate = findClosestPoint(shifted);
                    if (candidate.point && candidate.diff < MAX_DIFF) { bestMatch = candidate; break; }
                }
                if (!bestMatch) return alert(`[${file.name}] ç„¡æ³•åŒ¹é…è»Œè·¡é»ã€‚`);
                const reader = new FileReader();
                reader.onload = (ev) => addPhotoMarker(bestMatch.point, ev.target.result, file.name, photoDate);
                reader.readAsDataURL(file);
            }

            function findClosestPoint(targetDate) {
                let best = null, min = Infinity;
                const ts = targetDate.getTime();
                trackPointsPool.forEach(pt => {
                    const diff = Math.abs(pt.time.getTime() - ts);
                    if (diff < min) { min = diff; best = pt; }
                });
                return { point: best, diff: min };
            }

            function addPhotoMarker(pt, src, filename, date, customName = null) {
                const icon = L.divIcon({ className: 'photo-marker-icon', html: 'ğŸ“·', iconSize: [30, 30], iconAnchor: [15, 15] });
                const marker = L.marker([pt.lat, pt.lon], { icon });
                marker.addTo(map);
                const id = L.stamp(marker);

                const updateUI = (name) => {
                    const title = name || "æœªå‘½åç…§ç‰‡";
                    const popupHtml = `
                        <div style="text-align:center; min-width:160px;">
                            <img src="${src || ''}" style="width:100%; border-radius:6px; margin-bottom:5px; display:${src ? 'block' : 'none'};">
                            <div style="font-size:12px; font-weight:bold;">${title}</div>
                            <div style="font-size:10px; color:#666; margin-top:3px;">${date ? date.toLocaleString() : ''}</div>
                            <hr style="margin:8px 0; border:0; border-top:1px solid #eee;">
                            <div style="display:flex; flex-direction:column; gap:4px; margin-bottom:5px;">
                                <button onclick="window.checkWeather(${pt.lat}, ${pt.lon}, decodeURIComponent('${encodeURIComponent(title)}'))" style="background:#667eea; color:white; border:none; padding:4px; border-radius:3px; font-size:11px; cursor:pointer;">ğŸŒ¤ï¸ æŸ¥çœ‹å¤©æ°£</button>
                            </div>
                            <div style="display:flex; gap:5px; justify-content:center;">
                                <button onclick="window.editMarkerName(${id}, 'photo')" style="color:var(--primary); background:none; border:1px solid #ddd; cursor:pointer; padding:3px 8px; border-radius:4px; font-size:10px;">ä¿®æ”¹åç¨±</button>
                                <button onclick="window.removeWP(${id})" style="color:red; background:none; border:1px solid #fee2e2; cursor:pointer; padding:3px 8px; border-radius:4px; font-size:10px;">åˆªé™¤</button>
                            </div>
                        </div>
                    `;
                    marker.bindPopup(popupHtml);
                    if (name) marker.bindTooltip(name, { permanent: true, direction: 'top', className: 'wp-label photo-label', offset: [0, -15] });
                    else if (marker.getTooltip()) marker.unbindTooltip();
                };

                updateUI(customName);
                photos.push({ id, marker, lat: pt.lat, lon: pt.lon, name: customName, originalFile: filename, date, src });
                if (!document.getElementById('labelToggle').checked) map.removeLayer(marker);
            }

            // 2. é«˜åº¦å‰–æåœ–èˆ‡è³‡è¨Šé¢æ¿æ›´æ–°
            function showElevation(route) {
                currentRoute = route; // Save reference
                const panel = document.getElementById('elevation-panel');
                panel.classList.add('active');
                panel.classList.remove('collapsed');
                document.getElementById('toggle-text').textContent = 'â–¼ æ”¶åˆé«˜åº¦åœ–';
                updateInfoPanel(route);

                if (elevationChart) elevationChart.destroy();
                const ctx = document.getElementById('elevation-chart').getContext('2d');

                let data, label, color, unit, yMin = undefined;

                if (currentChartType === 'slope') {
                    data = calculateSmoothedSlope(route.pts);
                    label = 'å¡åº¦ (%)';
                    color = '#f97316';
                    unit = '%';
                } else if (currentChartType === 'speed') {
                    data = calculateSmoothedSpeed(route.pts);
                    label = 'é€Ÿåº¦ (km/h)';
                    color = '#3b82f6';
                    unit = 'km/h';
                    yMin = 0;
                } else {
                    data = route.pts.map(p => p.ele);
                    label = 'é«˜åº¦ (m)';
                    color = route.color;
                    unit = 'm';
                }

                const grad = ctx.createLinearGradient(0, 0, 0, 150);
                grad.addColorStop(0, color.replace('hsl', 'hsla').replace(')', ', 0.5)'));
                if (color.startsWith('#')) {
                    // Simple hex to rgba approximation for simplicity or just use consistent opacity
                    grad.addColorStop(0, color + '80');
                }
                grad.addColorStop(1, 'rgba(255,255,255,0)');

                elevationChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: route.pts.map(p => (p.dist / 1000).toFixed(1)),
                        datasets: [{
                            label: label,
                            data: data,
                            borderColor: color,
                            backgroundColor: grad,
                            fill: true,
                            tension: 0.1, // Less tension for slope/speed to be accurate
                            pointRadius: 0,
                            pointHitRadius: 10,
                            borderWidth: 2,
                            segment: {
                                borderColor: ctx => {
                                    if (dragStartIndex !== -1 && window.dragCurrentIndex !== undefined) {
                                        const idx = ctx.p0DataIndex;
                                        const start = Math.min(dragStartIndex, window.dragCurrentIndex);
                                        const end = Math.max(dragStartIndex, window.dragCurrentIndex);
                                        if (idx >= start && idx < end) return '#ffff00'; // é«˜äº®é¡è‰²
                                    }
                                    return undefined;
                                },
                                borderWidth: ctx => {
                                    if (dragStartIndex !== -1 && window.dragCurrentIndex !== undefined) {
                                        const idx = ctx.p0DataIndex;
                                        const start = Math.min(dragStartIndex, window.dragCurrentIndex);
                                        const end = Math.max(dragStartIndex, window.dragCurrentIndex);
                                        if (idx >= start && idx < end) return 4;
                                    }
                                    return undefined;
                                }
                            }
                        }]
                    },
                    options: {
                        events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove', 'mousedown', 'mouseup'],
                        responsive: true, maintainAspectRatio: false,
                        animation: false,
                        interaction: { mode: 'index', intersect: false, axis: 'x' },
                        onHover: (e, els) => {
                            const points = route.pts;
                            if (els.length > 0) {
                                const idx = els[0].index;
                                const pt = points[idx];
                                syncMarker.setLatLng([pt.lat, pt.lon]).setStyle({ opacity: 1 });
                            } else syncMarker.setStyle({ opacity: 0 });
                        },
                        plugins: {
                            legend: { display: true }, // Enable legend to show what chart it is
                            tooltip: { enabled: true, mode: 'index', intersect: false }
                        },
                        scales: {
                            x: { ticks: { font: { size: 8 } } },
                            y: {
                                min: yMin,
                                ticks: { font: { size: 9 } },
                                title: { display: true, text: unit }
                            }
                        }
                    },
                    plugins: [{
                        id: 'dragSelect',
                        afterEvent(chart, args) {
                            // Prevent infinite recursion when chart.update() triggers event replay
                            if (args.replay) return;

                            const { event } = args;
                            const x = event.x;
                            const y = event.y;

                            // Check if inside chart area
                            if (x < chart.chartArea.left || x > chart.chartArea.right || y < chart.chartArea.top || y > chart.chartArea.bottom) {
                                // If we are dragging and go out of bounds, we might want to still update the selection to the edge?
                                // For now, just ignore events outside strictly (except mouseup/out to stop drag)
                                if (event.type === 'mouseup' || event.type === 'mouseout') {
                                    if (dragStartIndex !== -1) {
                                        dragStartIndex = -1;
                                        window.dragCurrentIndex = undefined;
                                    }
                                }
                                return;
                            }

                            let xVal = chart.scales.x.getValueForPixel(x);

                            // Safety clamp to ensure valid array index
                            if (xVal === undefined || xVal === null) return;
                            if (xVal < 0) xVal = 0;
                            if (xVal >= route.pts.length) xVal = route.pts.length - 1;

                            if (event.type === 'mousedown') {
                                resetSelection(); // Clear previous selection
                                dragStartIndex = xVal;
                                window.dragCurrentIndex = xVal;
                            } else if (event.type === 'mousemove' && dragStartIndex !== -1) {
                                window.dragCurrentIndex = xVal;
                                chart.update('none'); // Efficient update
                                updateSelectionStats(route.pts, dragStartIndex, window.dragCurrentIndex);
                            } else if (event.type === 'mouseup') {
                                dragStartIndex = -1;
                                window.dragCurrentIndex = undefined;
                            } else if (event.type === 'mouseout') {
                                if (dragStartIndex !== -1) {
                                    dragStartIndex = -1;
                                    window.dragCurrentIndex = undefined;
                                }
                            }
                        }
                    }]
                });
            }

            function updateSelectionStats(pts, startIdx, endIdx) {
                const i1 = Math.min(startIdx, endIdx);
                const i2 = Math.max(startIdx, endIdx);
                if (i2 <= i1) return;

                // 1. åœ¨åœ°åœ–ä¸Šé«˜äº®é¡¯ç¤º
                const segment = pts.slice(i1, i2 + 1);
                if (selectionPolyline) map.removeLayer(selectionPolyline);
                selectionPolyline = L.polyline(segment.map(p => [p.lat, p.lon]), { color: '#ffff00', weight: 8, opacity: 0.8 }).addTo(map);

                // 2. è¨ˆç®—çµ±è¨ˆæ•¸æ“š
                const dist = (pts[i2].dist - pts[i1].dist) / 1000;
                const gain = pts[i2].ele - pts[i1].ele;
                const slope = dist > 0 ? (gain / (dist * 1000)) * 100 : 0;

                const statsBox = document.getElementById('selection-stats');
                statsBox.style.display = 'block';
                document.getElementById('sel-dist').textContent = dist.toFixed(2);
                document.getElementById('sel-gain').textContent = (gain > 0 ? '+' : '') + gain.toFixed(0);
                document.getElementById('sel-slope').textContent = slope.toFixed(1);

                // Add Edit Buttons to Stats Box
                const btnContainer = document.createElement('div');
                btnContainer.style.marginTop = '8px';
                btnContainer.style.display = 'flex';
                btnContainer.style.gap = '5px';

                const cropBtn = document.createElement('button');
                cropBtn.textContent = 'âœ‚ï¸ ä¿ç•™æ­¤æ®µ';
                cropBtn.className = 'action-btn';
                cropBtn.style.padding = '4px 8px';
                cropBtn.style.fontSize = '11px';
                cropBtn.style.background = '#e67e22';
                cropBtn.onclick = (e) => { e.stopPropagation(); cropRouteSegment(pts, i1, i2); };

                const delBtn = document.createElement('button');
                delBtn.textContent = 'ğŸ—‘ï¸ åˆªé™¤æ­¤æ®µ';
                delBtn.className = 'action-btn';
                delBtn.style.padding = '4px 8px';
                delBtn.style.fontSize = '11px';
                delBtn.style.background = '#c0392b';
                delBtn.onclick = (e) => { e.stopPropagation(); deleteRouteSegment(pts, i1, i2); };

                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'âŒ å–æ¶ˆ';
                cancelBtn.className = 'action-btn';
                cancelBtn.style.padding = '4px 8px';
                cancelBtn.style.fontSize = '11px';
                cancelBtn.style.background = '#95a5a6';
                cancelBtn.onclick = (e) => { e.stopPropagation(); resetSelection(); };

                btnContainer.append(cropBtn, delBtn, cancelBtn);

                // Clear previous buttons if any
                const existingBtns = statsBox.querySelector('.edit-btns');
                if (existingBtns) existingBtns.remove();

                btnContainer.className = 'edit-btns';
                statsBox.appendChild(btnContainer);
            }

            function cropRouteSegment(pts, startIndex, endIndex) {
                if (!confirm("ç¢ºå®šè¦åªä¿ç•™é¸å–çš„ç¯„åœï¼Œä¸¦åˆªé™¤å…¶ä»–éƒ¨åˆ†å—ï¼Ÿ")) return;

                // Find which route these points belong to
                const route = routes.find(r => r.pts.includes(pts[0]));
                if (!route) return;

                const newPts = route.pts.slice(startIndex, endIndex + 1);
                updateRouteData(route, newPts);

                // Rebuild trackPointsPool to keep data consistent (remove deleted points)
                trackPointsPool = routes.flatMap(r => r.pts);

                resetSelection();
            }

            function deleteRouteSegment(pts, startIndex, endIndex) {
                if (!confirm("ç¢ºå®šè¦åˆªé™¤é¸å–çš„ç¯„åœï¼Œä¸¦å°‡å‰å¾Œé€£æ¥èµ·ä¾†å—ï¼Ÿ")) return;

                const route = routes.find(r => r.pts.includes(pts[0]));
                if (!route) return;

                const newPts = [...route.pts];
                newPts.splice(startIndex, endIndex - startIndex + 1);

                if (newPts.length < 2) return alert("å‰©é¤˜é»æ•¸éå°‘ï¼Œç„¡æ³•åˆªé™¤");
                updateRouteData(route, newPts);

                // Rebuild trackPointsPool to keep data consistent (remove deleted points)
                trackPointsPool = routes.flatMap(r => r.pts);

                resetSelection();
            }

            function resetSelection() {
                document.getElementById('selection-stats').style.display = 'none';
                if (selectionPolyline) { map.removeLayer(selectionPolyline); selectionPolyline = null; }
                dragStartIndex = -1;
                window.dragCurrentIndex = undefined;
                if (elevationChart) elevationChart.update('none');
            }

            function reverseRoute(route) {
                if (!confirm("ç¢ºå®šè¦åè½‰é€™æ¢è·¯ç·šçš„æ–¹å‘å—ï¼Ÿ")) return;
                const newPts = [...route.pts].reverse();
                // Re-calculate distances and time? 
                // Time is tricky. Ideally we just reverse order, but keep timestamps? 
                // No, physical reverse means time should effectively reset or just keep geometry.
                // Simple reverse: just reverse geometry array.
                // But timestamps will be backwards. We should probably regenerate timestamps or just ignore them for speed calc?
                // Let's just reverse the array and recalculate cumulative distance.
                // We will lose original timestamps functionality if we don't be careful. 
                // For simplicity: Reverse array, Set Start Time = Old Start Time, and increment by original deltas reversed?
                // Hard mode. 
                // Lazy mode: Just reverse array. The chart will look weird if x-axis is time. But x-axis is dist.
                // Distance needs recalculation.

                let curDist = 0;
                for (let i = 0; i < newPts.length; i++) {
                    newPts[i].dist = curDist;
                    if (i < newPts.length - 1) {
                        curDist += getFlatDist(newPts[i], newPts[i + 1]);
                    }
                }
                updateRouteData(route, newPts);
            }

            function updateRouteData(route, newPts) {
                // Update internal data
                route.pts = newPts;

                // Redraw Polyline
                route.polyline.setLatLngs(newPts.map(p => [p.lat, p.lon]));

                // Redraw Slope Layer
                route.slopeLayer.clearLayers();
                for (let i = 0; i < newPts.length - 1; i++) {
                    const d = getFlatDist(newPts[i], newPts[i + 1]), s = d > 0 ? ((newPts[i + 1].ele - newPts[i].ele) / d) * 100 : 0;
                    let c = (s >= 0) ? (s <= 5 ? '#22c55e' : (s <= 15 ? '#eab308' : (s <= 30 ? '#f97316' : '#ef4444'))) : '#3b82f6';
                    L.polyline([[newPts[i].lat, newPts[i].lon], [newPts[i + 1].lat, newPts[i + 1].lon]], { color: c, weight: 6 }).addTo(route.slopeLayer);
                }

                // Redraw KM markers
                route.kmLayer.clearLayers();
                let nextKm = 1000;
                newPts.forEach(p => {
                    if (p.dist >= nextKm) {
                        const kmVal = Math.floor(p.dist / 1000);
                        L.marker([p.lat, p.lon], {
                            icon: L.divIcon({ className: 'km-marker', html: kmVal + 'k', iconSize: [24, 24] })
                        }).addTo(route.kmLayer);
                        nextKm += 1000;
                    }
                });

                // Update UI
                if (elevationChart) showElevation(route);
            }

            window.takeSnapshot = () => {
                document.getElementById('header').classList.remove('collapsed'); // å¼·åˆ¶é¡¯ç¤ºæ¨™é¡Œ
                const btn = document.querySelector('.snapshot-btn');
                const originalText = btn.textContent;
                btn.textContent = 'â³';

                html2canvas(document.body, { useCORS: true }).then(canvas => {
                    const a = document.createElement('a');
                    a.href = canvas.toDataURL("image/png");
                    a.download = `GPX_Snapshot_${new Date().getTime()}.png`;
                    a.click();
                    btn.textContent = originalText;
                }).catch(err => {
                    alert("æˆªåœ–å¤±æ•—: " + err);
                    btn.textContent = originalText;
                });
            };

            function updateInfoPanel(route) {
                const panel = document.getElementById('info-panel');
                panel.classList.add('active');
                let gain = 0;
                route.pts.forEach((p, i) => { if (i > 0 && p.ele > route.pts[i - 1].ele) gain += (p.ele - route.pts[i - 1].ele); });

                const distKm = route.pts[route.pts.length - 1].dist / 1000;
                const durationMs = route.pts[route.pts.length - 1].time.getTime() - route.pts[0].time.getTime();
                const speed = durationMs > 0 ? (distKm / (durationMs / 3600000)) : 0;

                const hrs = Math.floor(durationMs / 3600000);
                const mins = Math.floor((durationMs % 3600000) / 60000);

                const eleArr = route.pts.map(p => p.ele);
                document.getElementById('info-disp-name').textContent = route.name.substring(0, 15);
                document.getElementById('info-dist').textContent = distKm.toFixed(2) + ' km';
                document.getElementById('info-max-ele').textContent = Math.max(...eleArr).toFixed(0) + ' m';
                document.getElementById('info-min-ele').textContent = Math.min(...eleArr).toFixed(0) + ' m';
                document.getElementById('info-gain').textContent = gain.toFixed(0) + ' m';
                document.getElementById('info-speed').textContent = speed.toFixed(1) + ' km/h';
                document.getElementById('info-duration').textContent = `${hrs}æ™‚ ${mins}åˆ†`;
                document.getElementById('info-start').textContent = route.pts[0].time.toLocaleString();
                document.getElementById('info-end').textContent = route.pts[route.pts.length - 1].time.toLocaleString();
            }

            // 3. GPX è®€å–
            document.getElementById('fileInput').onchange = async (e) => {
                const files = Array.from(e.target.files);
                for (let file of files) {
                    const text = await file.text();
                    const xml = new DOMParser().parseFromString(text, "text/xml");
                    const trkpts = Array.from(xml.querySelectorAll('trkpt'));
                    let curDist = 0;
                    const pts = trkpts.map((pt, i) => {
                        const lat = parseFloat(pt.getAttribute('lat')), lon = parseFloat(pt.getAttribute('lon') || pt.getAttribute('lng')), ele = parseFloat(pt.querySelector('ele')?.textContent || 0), time = pt.querySelector('time')?.textContent;
                        const p = { lat, lon, ele, time: time ? new Date(time) : new Date(), dist: 0 };
                        if (i > 0) curDist += getFlatDist({ lat: parseFloat(trkpts[i - 1].getAttribute('lat')), lon: parseFloat(trkpts[i - 1].getAttribute('lon')) }, p);
                        p.dist = curDist; return p;
                    }).filter(p => !isNaN(p.lat) && !isNaN(p.lon));

                    if (pts.length > 0) {
                        const color = pathColors[routes.length % pathColors.length];
                        const polyline = L.polyline(pts.map(p => [p.lat, p.lon]), { color, weight: 6, opacity: 0.9 }).addTo(map);

                        // é‡Œç¨‹ç¢‘åœ–å±¤
                        const kmLayer = L.layerGroup();
                        let nextKm = 1000;
                        pts.forEach(p => {
                            if (p.dist >= nextKm) {
                                const kmVal = Math.floor(p.dist / 1000);
                                L.marker([p.lat, p.lon], {
                                    icon: L.divIcon({ className: 'km-marker', html: kmVal + 'k', iconSize: [24, 24] })
                                }).addTo(kmLayer);
                                nextKm += 1000;
                            }
                        });
                        kmLayer.addTo(map);

                        const slopeLayer = L.layerGroup();
                        for (let i = 0; i < pts.length - 1; i++) {
                            const d = getFlatDist(pts[i], pts[i + 1]), s = d > 0 ? ((pts[i + 1].ele - pts[i].ele) / d) * 100 : 0;
                            let c = (s >= 0) ? (s <= 5 ? '#22c55e' : (s <= 15 ? '#eab308' : (s <= 30 ? '#f97316' : '#ef4444'))) : '#3b82f6';
                            L.polyline([[pts[i].lat, pts[i].lon], [pts[i + 1].lat, pts[i + 1].lon]], { color: c, weight: 6 }).addTo(slopeLayer);
                        }
                        const routeObj = { name: file.name, pts, polyline, slopeLayer, color, kmLayer };
                        routes.push(routeObj); trackPointsPool.push(...pts); addRouteUI(routeObj); map.fitBounds(polyline.getBounds(), { padding: [50, 50] });
                    }

                    xml.querySelectorAll('wpt').forEach(wp => {
                        const lat = parseFloat(wp.getAttribute('lat')), lon = parseFloat(wp.getAttribute('lon') || wp.getAttribute('lng')), name = wp.querySelector('name')?.textContent || "åœ°æ¨™";
                        if (!isNaN(lat) && !isNaN(lon)) {
                            if (name.includes('ğŸ“·')) addPhotoMarker({ lat, lon }, null, null, null, name);
                            else createWaypointMarker(lat, lon, name);
                        }
                    });
                }
                document.getElementById('addWaypointBtn').disabled = false;
                document.getElementById('exportBtn').disabled = false;
            };

            function createWaypointMarker(lat, lng, name) {
                const marker = L.marker([lat, lng]);
                marker.addTo(map);
                const id = L.stamp(marker);
                const updateUI = (n) => {
                    marker.bindTooltip(n, { permanent: true, direction: 'top', className: 'wp-label', offset: [0, -10] });
                    marker.bindPopup(`
                        <b>${n}</b><br>
                        <div style="margin-top:8px; display:flex; flex-direction:column; gap:4px;">
                            <button onclick="window.checkWeather(${lat}, ${lng}, decodeURIComponent('${encodeURIComponent(n)}'))" style="background:#667eea; color:white; border:none; padding:4px; border-radius:3px; font-size:11px; cursor:pointer;">ğŸŒ¤ï¸ æŸ¥çœ‹å¤©æ°£</button>
                            <div style="display:flex; gap:4px;">
                                <button onclick="window.editMarkerName(${id}, 'waypoint')" style="flex:1; font-size:10px; cursor:pointer;">ä¿®æ”¹</button>
                                <button onclick="window.removeWP(${id})" style="flex:1; color:red; font-size:10px; cursor:pointer;">åˆªé™¤</button>
                            </div>
                        </div>
                    `);
                };
                updateUI(name);
                waypoints.push({ id, marker, lat, lng, name });
                if (!document.getElementById('labelToggle').checked) map.removeLayer(marker);
            }

            function getFlatDist(p1, p2) {
                const R = 6371000, dLat = (p2.lat - p1.lat) * Math.PI / 180, dLon = (p2.lon - p1.lon) * Math.PI / 180;
                const a = Math.sin(dLat / 2) ** 2 + Math.cos(p1.lat * Math.PI / 180) * Math.cos(p2.lat * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
                return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            }

            window.editMarkerName = (id, type) => {
                currentNamingTarget = { id, type };
                const obj = (type === 'photo') ? photos.find(p => p.id === id) : waypoints.find(w => w.id === id);
                document.getElementById('namingTitle').textContent = (type === 'photo') ? "ğŸ“· ä¿®æ”¹ç…§ç‰‡åç¨±" : "ğŸ“ ä¿®æ”¹åœ°æ¨™åç¨±";
                document.getElementById('targetNameInput').value = obj.name || "";
                document.getElementById('namingModal').style.display = 'flex';
            };

            document.getElementById('confirmNaming').onclick = () => {
                const newName = document.getElementById('targetNameInput').value.trim();
                if (!newName) return alert("è«‹è¼¸å…¥åç¨±");
                if (currentNamingTarget) {
                    if (currentNamingTarget.type === 'photo') {
                        const photo = photos.find(p => p.id === currentNamingTarget.id);
                        photo.name = newName.startsWith('ğŸ“·') ? newName : `ğŸ“· ${newName}`;
                        photo.marker.bindTooltip(photo.name, { permanent: true, direction: 'top', className: 'wp-label photo-label', offset: [0, -15] });
                    } else {
                        const wp = waypoints.find(w => w.id === currentNamingTarget.id);
                        wp.name = newName; wp.marker.setTooltipContent(newName);
                    }
                    currentNamingTarget = null;
                } else if (pendingWaypointLatLng) {
                    createWaypointMarker(pendingWaypointLatLng.lat, pendingWaypointLatLng.lng, newName);
                    pendingWaypointLatLng = null;
                }
                closeModal('namingModal');
            };

            window.removeWP = (id) => {
                const idx = waypoints.findIndex(w => w.id === id);
                if (idx !== -1) { map.removeLayer(waypoints[idx].marker); waypoints.splice(idx, 1); }
                const pix = photos.findIndex(p => p.id === id);
                if (pix !== -1) { map.removeLayer(photos[pix].marker); photos.splice(pix, 1); }
            };

            document.getElementById('labelToggle').onchange = function (e) {
                const isVisible = e.target.checked;
                [...waypoints, ...photos].forEach(item => {
                    if (isVisible) item.marker.addTo(map);
                    else map.removeLayer(item.marker);
                });
            };

            function addRouteUI(route) {
                const wrapper = document.createElement('div');
                wrapper.className = 'route-wrapper';
                const btn = document.createElement('button');
                btn.className = 'route-button'; btn.style.background = route.color;
                btn.textContent = route.name.substring(0, 10); btn.onclick = () => showElevation(route);

                const zBtn = document.createElement('button');
                zBtn.className = 'zoom-btn'; zBtn.innerHTML = 'ğŸ”';
                zBtn.title = "èšç„¦è·¯ç·š";
                zBtn.onclick = (e) => { e.stopPropagation(); map.fitBounds(route.polyline.getBounds()); };

                const revBtn = document.createElement('button');
                revBtn.className = 'zoom-btn';
                revBtn.style.borderRadius = "4px"; // Square style
                revBtn.innerHTML = 'ğŸ”„';
                revBtn.title = "åè½‰è·¯ç·š";
                revBtn.onclick = (e) => { e.stopPropagation(); reverseRoute(route); };

                wrapper.append(btn, zBtn, revBtn);
                document.getElementById('route-list').appendChild(wrapper);
            }

            document.getElementById('elevation-toggle-handle').onclick = function (e) {
                if (e.target.closest('.chart-controls-container')) return; // Ignore clicks on buttons
                const panel = document.getElementById('elevation-panel');
                panel.classList.toggle('collapsed');
                document.getElementById('toggle-text').textContent = panel.classList.contains('collapsed') ? 'â–² å±•é–‹é«˜åº¦åœ–' : 'â–¼ æ”¶åˆé«˜åº¦åœ–';
            };

            document.getElementById('header-handle').onclick = function () {
                const h = document.getElementById('header');
                h.classList.toggle('collapsed');
                this.textContent = h.classList.contains('collapsed') ? 'â–¼' : 'â–²';
            };

            map.on('click', (e) => {
                if (!isAddingWaypoint) return;
                pendingWaypointLatLng = e.latlng;
                currentNamingTarget = null;
                document.getElementById('namingModal').style.display = 'flex';
                isAddingWaypoint = false;
                map.getContainer().style.cursor = '';
                document.getElementById('addWaypointBtn').style.background = '';
                document.getElementById('addWaypointBtn').textContent = 'ğŸ“ æ–°å¢åœ°æ¨™';
            });

            document.getElementById('addWaypointBtn').onclick = function () {
                isAddingWaypoint = !isAddingWaypoint;
                this.style.background = isAddingWaypoint ? '#ff6b6b' : '';
                this.textContent = isAddingWaypoint ? 'ğŸ“ é»æ“Šåœ°åœ–æ”¾ç½®' : 'ğŸ“ æ–°å¢åœ°æ¨™';
                map.getContainer().style.cursor = isAddingWaypoint ? 'crosshair' : '';
            };

            document.getElementById('exportBtn').onclick = () => {
                const container = document.getElementById('export-choices');
                container.innerHTML = '';
                routes.forEach((r, i) => {
                    container.innerHTML += `<label style="display:block; font-size:12px; margin:6px 0; cursor:pointer;"><input type="checkbox" class="exp-chk" value="${i}" checked> ${r.name}</label>`;
                });
                document.getElementById('exportModal').style.display = 'flex';
            };

            document.getElementById('finalExportBtn').onclick = () => {
                const selected = Array.from(document.querySelectorAll('.exp-chk:checked')).map(el => parseInt(el.value));
                if (selected.length === 0) return alert("è«‹å‹¾é¸è·¯ç·š");
                let xml = `<?xml version="1.0" encoding="UTF-8"?><gpx version="1.1" creator="HikingMapTool/${APP_VERSION}" xmlns="http://www.topografix.com/GPX/1/1">`;
                selected.forEach(idx => {
                    const r = routes[idx];
                    xml += `<trk><name>${r.name.replace(/&/g, "&amp;")}</name><trkseg>${r.pts.map(p => `<trkpt lat="${p.lat}" lon="${p.lon}"><ele>${p.ele}</ele><time>${p.time.toISOString()}</time></trkpt>`).join('')}</trkseg></trk>`;
                });
                if (document.getElementById('chk-export-wp').checked) {
                    [...waypoints, ...photos].forEach(wp => {
                        xml += `<wpt lat="${wp.lat}" lon="${wp.lon}"><name>${(wp.name || "æ¨™è¨˜").replace(/&/g, "&amp;")}</name></wpt>`;
                    });
                }
                xml += `</gpx>`;
                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([xml], { type: 'application/gpx+xml' }));
                a.download = `ç™»å±±åŒ¯å‡º_${new Date().getTime()}.gpx`; a.click();
                closeModal('exportModal');
            };

            document.getElementById('slopeToggle').onchange = (e) => {
                const active = e.target.checked;
                document.getElementById('slopeLegend').classList.toggle('active', active);
                routes.forEach(r => {
                    if (active) { map.removeLayer(r.polyline); r.slopeLayer.addTo(map); }
                    else { map.removeLayer(r.slopeLayer); r.polyline.addTo(map); }
                });
            };

            // æœå°‹é‚è¼¯
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('search-results');

            async function doSearch() {
                const q = searchInput.value.trim();
                if (!q) return;
                searchResults.style.display = 'block';
                searchResults.innerHTML = '<div class="search-item">æœå°‹ä¸­...</div>';

                try {
                    const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
                    const data = await res.json();
                    searchResults.innerHTML = '';
                    if (data.length === 0) {
                        searchResults.innerHTML = '<div class="search-item">æ‰¾ä¸åˆ°çµæœ</div>';
                        return;
                    }
                    data.forEach(item => {
                        const div = document.createElement('div');
                        div.className = 'search-item';
                        div.textContent = item.display_name;
                        div.onclick = () => {
                            const lat = parseFloat(item.lat), lon = parseFloat(item.lon);
                            map.flyTo([lat, lon], 14);
                            L.marker([lat, lon]).addTo(map).bindPopup(item.display_name).openPopup();
                            searchResults.style.display = 'none';
                        };
                        searchResults.appendChild(div);
                    });
                } catch (e) {
                    searchResults.innerHTML = '<div class="search-item" style="color:red;">æœå°‹éŒ¯èª¤</div>';
                }
            }

            document.getElementById('searchBtn').onclick = doSearch;
            searchInput.onkeypress = (e) => { if (e.key === 'Enter') doSearch(); };

            document.addEventListener('click', (e) => {
                if (!e.target.closest('#search-results') && e.target !== searchInput) {
                    searchResults.style.display = 'none';
                }
            });

            // å¤©æ°£é‚è¼¯
            const weatherCodes = {
                0: "æ™´æœ—", 1: "å¤§è‡´æ™´æœ—", 2: "å¤šé›²", 3: "é™°å¤©",
                45: "éœ§", 48: "éœ§å‡‡", 51: "æ¯›æ¯›é›¨", 53: "æ¯›æ¯›é›¨", 55: "æ¯›æ¯›é›¨",
                61: "å°é›¨", 63: "ä¸­é›¨", 65: "å¤§é›¨", 80: "é™£é›¨", 81: "é™£é›¨", 82: "å¼·é™£é›¨",
                95: "é›·é›¨", 96: "é›·é›¨ä¼´å†°é›¹", 99: "é›·é›¨ä¼´å†°é›¹"
            };

            window.toggleFullScreen = () => {
                const isFull = document.body.classList.toggle('fullscreen-mode');

                if (isFull) {
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen();
                    }
                } else {
                    if (document.exitFullscreen && document.fullscreenElement) {
                        document.exitFullscreen();
                    }
                }

                // Wait for transition/resize
                setTimeout(() => {
                    map.invalidateSize();
                    if (isFull && routes.length > 0) {
                        // Manual bounds calculation for robustness with multiple files
                        const bounds = L.latLngBounds([]);
                        let valid = false;
                        routes.forEach(r => {
                            if (r.polyline) {
                                const b = r.polyline.getBounds();
                                if (b.isValid()) {
                                    bounds.extend(b);
                                    valid = true;
                                }
                            }
                        });

                        if (valid) {
                            // Calculate padding to achieve ~98% fill (1% margin) for maximum visibility
                            const pX = window.innerWidth * 0.01;
                            const pY = window.innerHeight * 0.01;
                            map.fitBounds(bounds, {
                                padding: [pY, pX],
                                maxZoom: 18
                            });
                        }
                    }
                }, 200);
            };

            window.takeSnapshot = () => {
                const btnText = 'â³';
                const btns = document.querySelectorAll('button[title="ç•«é¢å¿«ç…§"], button[title="å¿«ç…§"]');
                btns.forEach(b => {
                    if (!b.dataset.org) b.dataset.org = b.innerHTML;
                    b.innerHTML = btnText;
                });

                document.body.classList.add('snapshot-active');

                // Wait for UI to hide
                requestAnimationFrame(() => {
                    // Use dom-to-image for better transform support
                    domtoimage.toPng(document.body, {
                        filter: (node) => {
                            // Filter out hidden modals or non-visible elements if needed
                            // But CSS display:none !important handles it mostly.
                            // Ensure we don't capture the modals if they are visible
                            return true;
                        }
                    })
                        .then(function (dataUrl) {
                            const a = document.createElement('a');
                            a.href = dataUrl;
                            a.download = `GPX_Snapshot_${new Date().getTime()}.png`;
                            a.click();
                            restoreBtns();
                        })
                        .catch(function (error) {
                            console.error('oops, something went wrong!', error);
                            alert("æˆªåœ–å¤±æ•—: " + error);
                            restoreBtns();
                        });
                });

                function restoreBtns() {
                    document.body.classList.remove('snapshot-active');
                    btns.forEach(b => {
                        if (b.dataset.org) b.innerHTML = b.dataset.org;
                    });
                }
            };

            const getWeatherIcon = (code) => {
                /* ç°¡å–®å°‡ä»£ç¢¼æ˜ å°„ç‚ºè¡¨æƒ…ç¬¦è™Ÿ */
                if (code === 0) return "â˜€ï¸";
                if (code <= 3) return "â›…";
                if (code <= 48) return "ğŸŒ«ï¸";
                if (code <= 67) return "ğŸŒ§ï¸";
                if (code >= 95) return "âš¡";
                return "ğŸŒ§ï¸";
            };

            window.checkWeather = async (lat, lon, name) => {
                document.getElementById('weatherModal').style.display = 'flex';
                document.getElementById('weatherTitle').textContent = `ğŸŒ¤ï¸ ${name} - å¤©æ°£é å ±`;
                document.getElementById('weatherContent').innerHTML = 'è¼‰å…¥ä¸­...';

                try {
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=weathercode,temperature_2m_max,temperature_2m_min,precipitation_probability_max&timezone=auto`;
                    const res = await fetch(url);
                    const data = await res.json();

                    if (!data.daily) throw new Error("ç„¡æ•¸æ“š");

                    let html = '<div class="weather-grid">';
                    data.daily.time.forEach((t, i) => {
                        const code = data.daily.weathercode[i];
                        const icon = getWeatherIcon(code);
                        const desc = weatherCodes[code] || "æœªçŸ¥";
                        const min = data.daily.temperature_2m_min[i];
                        const max = data.daily.temperature_2m_max[i];
                        const rain = data.daily.precipitation_probability_max[i];

                        html += `
                            <div class="weather-card">
                                <div class="weather-date">${t.slice(5)}</div>
                                <div class="weather-icon">${icon}</div>
                                <div class="weather-temp">${min}Â° - ${max}Â°</div>
                                <div class="weather-desc">${desc}</div>
                                <div style="font-size:10px; color:#448aff;">â˜‚ï¸ ${rain}%</div>
                            </div>
                        `;
                    });
                    html += '</div><div style="text-align:right; font-size:10px; color:#999; margin-top:5px;">æ•¸æ“šæä¾›ï¼šOpen-Meteo</div>';
                    document.getElementById('weatherContent').innerHTML = html;
                } catch (e) {
                    document.getElementById('weatherContent').innerHTML = 'ç„¡æ³•å–å¾—å¤©æ°£è³‡è¨Š ' + e.message;
                }
            };

            window.closeModal = (id) => document.getElementById(id).style.display = 'none';

            // æ™‚é–“é ä¼°é‚è¼¯
            const estimateBtn = document.getElementById('estimateTimeBtn');
            const paceSlider = document.getElementById('pace-slider');
            const paceVal = document.getElementById('pace-val');
            let currentStats = { dist: 0, gain: 0 };

            function updateTimeCalc() {
                const pace = parseFloat(paceSlider.value);
                paceVal.textContent = pace.toFixed(1);

                // Naismith rule: 5km/h + 600m/1h (Classic is 5km, hiking often uses 4km)
                // Let's use 4km/h as base for "General Hiking" to be safer
                const naismithHours = (currentStats.dist / 4) + (currentStats.gain / 600);
                const normalTime = naismithHours / pace;

                // Munter Method: (Dist + Gain/100) / 4
                const munterUnits = currentStats.dist + (currentStats.gain / 100);
                const munterHours = (munterUnits / 4) / pace;

                document.getElementById('tm-normal').textContent = formatHrs(normalTime);
                document.getElementById('tm-conservative').textContent = formatHrs(munterHours);
            }

            function formatHrs(h) {
                const hours = Math.floor(h);
                const mins = Math.round((h - hours) * 60);
                return `${hours}å°æ™‚ ${mins}åˆ†`;
            }

            estimateBtn.onclick = () => {
                if (routes.length === 0) return alert("è«‹å…ˆè¼‰å…¥ GPX è»Œè·¡");

                let totalDist = 0;
                let totalGain = 0;

                routes.forEach(r => {
                    totalDist += r.pts[r.pts.length - 1].dist / 1000;
                    let g = 0;
                    r.pts.forEach((p, i) => {
                        if (i > 0 && p.ele > r.pts[i - 1].ele) g += (p.ele - r.pts[i - 1].ele);
                    });
                    totalGain += g;
                });

                currentStats = { dist: totalDist, gain: totalGain };

                document.getElementById('tm-dist').textContent = totalDist.toFixed(1);
                document.getElementById('tm-gain').textContent = totalGain.toFixed(0);

                updateTimeCalc();
                document.getElementById('timeModal').style.display = 'flex';
            };

            paceSlider.oninput = updateTimeCalc;

            // --- å°èˆªèˆ‡è¿½è¹¤åŠŸèƒ½ (Navigation) ---
            let watchId = null;
            let userPath = null;
            let userMarker = null;
            let userAccuracyCircle = null;
            let recordedPoints = [];
            const navBtn = document.getElementById('navBtn');
            const locateBtn = document.getElementById('locateBtn');
            const gpsStatus = document.getElementById('gps-status');

            navBtn.onclick = () => {
                if (watchId !== null) {
                    stopNavigation();
                } else {
                    startNavigation();
                }
            };

            locateBtn.onclick = () => {
                if (userMarker) {
                    map.setView(userMarker.getLatLng(), 16);
                }
            };

            function startNavigation() {
                if (!navigator.geolocation) return alert("æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´åœ°ç†å®šä½");

                navBtn.textContent = "ğŸ›‘ åœæ­¢å°èˆª";
                navBtn.style.background = "#c0392b";
                locateBtn.style.display = "inline-block";
                gpsStatus.style.display = "inline";

                // åˆå§‹åŒ–åœ–å±¤
                if (!userPath) {
                    userPath = L.polyline([], { color: '#2980b9', weight: 4, dashArray: '10, 10', opacity: 0.8 }).addTo(map);
                }

                watchId = navigator.geolocation.watchPosition(updatePosition, handleGpsError, {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                });
            }

            function stopNavigation() {
                if (watchId !== null) {
                    navigator.geolocation.clearWatch(watchId);
                    watchId = null;
                }
                navBtn.textContent = "ğŸ›°ï¸ é–‹å§‹å°èˆª";
                navBtn.style.background = "#2980b9";
                locateBtn.style.display = "none";
                gpsStatus.style.display = "none";
                gpsStatus.textContent = "";
            }

            function updatePosition(pos) {
                const lat = pos.coords.latitude;
                const lon = pos.coords.longitude;
                const acc = pos.coords.accuracy;
                const ele = pos.coords.altitude;

                const latlng = [lat, lon];

                // æ›´æ–°æ¨™è¨˜
                if (!userMarker) {
                    userMarker = L.circleMarker(latlng, {
                        radius: 8,
                        fillColor: "#3498db",
                        color: "#fff",
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8
                    }).addTo(map).bindPopup("ç›®å‰ä½ç½®");

                    userAccuracyCircle = L.circle(latlng, { radius: acc, color: '#3498db', weight: 1, fillOpacity: 0.1 }).addTo(map);

                    map.setView(latlng, 15); // åˆæ¬¡å®šä½è‡ªå‹•èšç„¦
                } else {
                    userMarker.setLatLng(latlng);
                    userAccuracyCircle.setLatLng(latlng).setRadius(acc);
                }

                // æ›´æ–°è»Œè·¡ (åªæœ‰ç•¶ç²¾åº¦å°šå¯æ™‚æ‰è¨˜éŒ„ï¼Œé¿å…äº‚é£„? é€™è£¡æš«ä¸è¨­é™ï¼Œå…¨è¨˜éŒ„)
                recordedPoints.push(latlng);
                userPath.addLatLng(latlng);

                // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
                let statusText = `ç²¾åº¦: Â±${Math.round(acc)}m`;
                if (ele !== null) statusText += ` | æµ·æ‹”: ${Math.round(ele)}m`;
                gpsStatus.textContent = statusText;
            }

            function handleGpsError(err) {
                console.warn('GPS Error:', err);
                gpsStatus.textContent = "âš ï¸ è¨Šè™Ÿå¾®å¼±æˆ–ç„¡æ¬Šé™";
            }

            // --- é›¢ç·šåœ°åœ–åŠŸèƒ½ (Offline Map) ---
            const offlineBtn = document.getElementById('offlineBtn');
            const offLayerName = document.getElementById('off-layer-name');
            const offCurrentZoom = document.getElementById('off-current-zoom');
            const offTileCount = document.getElementById('off-tile-count');
            const offZoomSelect = document.getElementById('off-zoom-select');
            const startDownloadBtn = document.getElementById('startDownloadBtn');

            let currentDownloadController = null;

            offlineBtn.onclick = () => {
                const z = map.getZoom();
                offCurrentZoom.textContent = z;

                // æ‰¾å‡ºç›®å‰ä½¿ç”¨çš„ Base Layer
                let activeName = "æœªçŸ¥";
                map.eachLayer(l => {
                    if (l._url && !l._url.includes('waymarkedtrails')) { // æ’é™¤ç–ŠåŠ å±¤
                        // ç°¡å–®åˆ¤æ–·ï¼šéæ­· baseMaps çš„ values ä¾†å°æ‡‰ keys (ç”±æ–¼ Leaflet æ²’æœ‰ç›´æ¥ API å–å¾—ç›®å‰ Layer Name)
                        Object.entries(baseMaps).forEach(([key, layer]) => {
                            if (map.hasLayer(layer)) activeName = key;
                        });
                    }
                });
                offLayerName.textContent = activeName;
                updateTileCount();
                document.getElementById('offlineModal').style.display = 'flex';
                document.getElementById('off-progress-container').style.display = 'none';
                startDownloadBtn.disabled = false;
                startDownloadBtn.textContent = 'ğŸš€ é–‹å§‹å¿«å–';
            };

            offZoomSelect.onchange = updateTileCount;
            map.on('moveend', () => {
                if (document.getElementById('offlineModal').style.display === 'flex') updateTileCount();
            });

            function updateTileCount() {
                const bounds = map.getBounds();
                const zStart = Math.floor(map.getZoom());
                const depth = parseInt(offZoomSelect.value);
                const zEnd = zStart + depth;

                let total = 0;
                for (let z = zStart; z <= zEnd; z++) {
                    const t = getTileRange(bounds, z);
                    total += (t.xMax - t.xMin + 1) * (t.yMax - t.yMin + 1);
                }
                offTileCount.textContent = total;
                if (total > 5000) offTileCount.style.color = 'red';
                else offTileCount.style.color = '#2980b9';
            }

            function getTileRange(bounds, zoom) {
                const n = Math.pow(2, zoom);
                const lat2t = (lat) => (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n;
                const lon2t = (lon) => (lon + 180) / 360 * n;

                return {
                    xMin: Math.floor(lon2t(bounds.getWest())),
                    xMax: Math.floor(lon2t(bounds.getEast())),
                    yMin: Math.floor(lat2t(bounds.getNorth())),
                    yMax: Math.floor(lat2t(bounds.getSouth()))
                };
            }

            startDownloadBtn.onclick = async () => {
                const bounds = map.getBounds();
                const zStart = Math.floor(map.getZoom());
                const depth = parseInt(offZoomSelect.value);
                const zEnd = zStart + depth;

                // å–å¾—ç›®å‰åœ–å±¤ URL Template
                let urlTemplate = "";
                map.eachLayer(l => {
                    if (l._url && !l._url.includes('waymarkedtrails') && map.hasLayer(l)) {
                        urlTemplate = l._url;
                    }
                });

                if (!urlTemplate) return alert("ç„¡æ³•åµæ¸¬ç›®å‰åº•åœ–ä¾†æº");

                startDownloadBtn.disabled = true;
                startDownloadBtn.textContent = 'ä¸‹è¼‰ä¸­...';
                document.getElementById('off-progress-container').style.display = 'block';

                const urls = [];
                for (let z = zStart; z <= zEnd; z++) {
                    const t = getTileRange(bounds, z);
                    for (let x = t.xMin; x <= t.xMax; x++) {
                        for (let y = t.yMin; y <= t.yMax; y++) {
                            // Leaflet logic for subdomains {s}
                            let url = urlTemplate.replace('{z}', z).replace('{x}', x).replace('{y}', y);
                            if (url.includes('{s}')) {
                                const subdomains = ['a', 'b', 'c'];
                                url = url.replace('{s}', subdomains[(x + y) % subdomains.length]);
                            }
                            urls.push(url);
                        }
                    }
                }

                currentDownloadController = new AbortController();
                await downloadTiles(urls, currentDownloadController.signal);
            };

            async function downloadTiles(urls, signal) {
                const total = urls.length;
                let loaded = 0;
                let failed = 0;
                const limit = 6; // ç€è¦½å™¨ä½µç™¼é™åˆ¶

                const updateProgress = () => {
                    const pct = Math.round((loaded / total) * 100);
                    document.getElementById('off-progress-bar').style.width = pct + '%';
                    document.getElementById('off-percent').textContent = pct + '%';
                    document.getElementById('off-status-text').textContent = `å·²ä¸‹è¼‰: ${loaded} / ${total} (å¤±æ•—: ${failed})`;
                };

                // ç°¡å–®çš„ Pool åŸ·è¡Œ
                async function fetchUrl(url) {
                    if (signal.aborted) return;
                    try {
                        await new Promise((resolve, reject) => {
                            const img = new Image();
                            img.crossOrigin = 'anonymous'; // å˜—è©¦è·¨åŸŸå¿«å–
                            img.src = url;
                            img.onload = resolve;
                            img.onerror = reject;
                        });
                    } catch (e) {
                        failed++;
                    } finally {
                        loaded++;
                        updateProgress();
                    }
                }

                // Chunk execution
                for (let i = 0; i < total; i += limit) {
                    if (signal.aborted) break;
                    const chunk = urls.slice(i, i + limit);
                    await Promise.all(chunk.map(fetchUrl));
                }

                if (!signal.aborted) {
                    startDownloadBtn.textContent = 'âœ… å®Œæˆ';
                    setTimeout(() => { startDownloadBtn.disabled = false; startDownloadBtn.textContent = 'ğŸš€ é–‹å§‹å¿«å–'; }, 2000);
                }
            }
        });
    </script>
</body>

</html>